
1. Развернул PostgreSQL на вм.
2. Отредактировал параметры в конфиг. файле и перезапустил postgresql:
```
log_lock_waits = on
deadlock_timeout = 1s
log_min_duration_statement = 0
log_statement = 'all'
log_connections = on
lock_timeout = 200ms
```
3. Cоздал необходимую таблицу и заполнил ее
```
CREATE TABLE test_locks (id serial PRIMARY KEY, value integer);
INSERT INTO test_locks (value) VALUES (10);
```
4. Подключился к PostgreSQL с помощью двух клиентов,чтобы это было как 2 разные сессии
5.  В первой сессии начнал транзакцию и выполнил запрос, который заблокирует таблицу или строку:
```
BEGIN;
UPDATE test_locks SET value = 20 WHERE id = 1;
```

6. В второй сессии  начал транзакцию и выполнил запрос, который пытается изменить ту же строку, что и в сессии 1:
```
BEGIN;
UPDATE test_locks SET value = 30 WHERE id = 1;
```
Вышла ошибка так как сессия 2 будет ждать освобождения блокировки, удерживаемой сессией 1.

7. В первой сессии выполнил COMMIT. Это должно освободить блокировку, и сессия 2 сможет завершить свой запрос.

8. В логах нашел сообщение об удержании блокировки,и время ожидания
9. Изучил возникшие блокировки в представлении pg_locks: как раз 2 процесса в статусе false 
```
tuple       | test_locks | ExclusiveLock   | NULL | 2/456 | 5678 | f

transactionid| NULL      | ShareLock       | 5678 | 3/789 | 9012 | f
```

10. Воспроизвел  взаимоблокировку трех транзакций. По логам можно разобрать ситуацию постфактум, так как PostgreSQL записывает детальную информацию о взаимоблокировках.В логах должно появится сообщение о взаимоблокировке с деталями:
```
ERROR:  deadlock detected
DETAIL:  Process 123 waits for ShareLock on transaction 456; blocked by process 789.
Process 789 waits for ShareLock on transaction 012; blocked by process 123.
```
11.Две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where),могут заблокировать друг друга.Например, при параллельном выполнении запросов или при использовании индексов может возникнуть взаимоблокировка.Если таблица достаточно большая и используется параллельное выполнение, разные worker'ы могут получить блокировки в разном порядке, что может привести к взаимоблокировке.

```
-- Сеанс 1:
BEGIN;
UPDATE test_locks SET value = value + 1; -- сканирует в порядке id 1,2,3...

-- Сеанс 2:
BEGIN;
UPDATE test_locks SET value = value + 1; -- при параллельном плане может сканировать в другом порядке
```









