
1. Установил PostgreSQL на вм.
2. Настроил выполнение контрольной точки раз в 30 секунд в конфиге postgresql, строка checkpoint_timeout = 30s и перезапустил postgresql
3. Запустил pgbench на 10 минут
```
pgbench -i 
pgbench -c 8 -j 2 -T 600 postgres > /tmp/pgbench.log
```
4. Измерил  объем журнальных файлов был сгенерирован за это время 81МB. В среднем на одну контрольную точку приходится 4.05МB.Для этого я переввел 10 минут в секунды и разделил на 30(т.к выставили такой таймаут в конфиге)чтобы получить количество контрольных точек,затем разделил общий размер WAL файлов на количество контрольных точек.

```
du -sh /var/lib/postgresql/15/main/pg_wal
```
5. Проверил данные статистики:checkpoints_timed показывает 43. Это говорит о том, что контрольные точки происходили чаще, чем задано, потому что нагрузка была достаточно высокой и вышли за дефолтные значения. Так как checkpoints_req всего 1, то в основном работала Time Based стратегия.

```
SELECT
    pg_stat_bgwriter.checkpoints_timed,
    pg_stat_bgwriter.checkpoints_req,
    pg_stat_bgwriter.buffers_checkpoint,
    pg_stat_bgwriter.buffers_clean,
    pg_stat_bgwriter.maxwritten_clean,
    pg_stat_bgwriter.buffers_backend,
    pg_stat_bgwriter.buffers_backend_fsync,
    pg_stat_bgwriter.buffers_alloc
FROM
    pg_stat_bgwriter;
```
6. Сравнил tps в синхронном/асинхронном режиме утилитой pgbench.В синхронном режиме получилось tps = 689.533517 (перед этим проверил,что synchronous_commit = on). В асинхронном получилось tps = 2094.989886 (переключил на synchronous_commit = off).Такая разница в значениях получилась из-за того,что асинхронном режиме транзакции подтверждаются до записи на диск. Это значительно повышает производительность, но увеличивает риск потери данных в случае сбоя.
7. Удалил существующий кластер, Создал новый кластер с включенной контрольной суммой страниц. Создал таблицу. Вставил несколько значений. Выключил кластер. Изменил пару байт в таблице. Включил кластер и сделал выборку из таблицы. Появилась ошибка,что чтение данных невозможно. Это могло произойти из-за того,что контрольные суммы страниц используются для обнаружения повреждений данных. При чтении страницы с диска PostgreSQL вычисляет контрольную сумму и сравнивает ее со значением, хранящимся на странице. Если они не совпадают, это указывает на повреждение данных.Чтобы проигнорировать ошибку нужно включить в конфиге постгреса параметр ignore_checksum_failure = on


